# 15강 고급 주제와 성능 최적화

## 엔티티 비교
영속성 컨텍스트 내부의 1차 캐시는 영속성 컨텍스트와 생명주기를 같이 한다

영속성 컨텍스트를 통해 데이터를 저장하거나 조회하면 1차 캐시에 엔티티가 저장된다

이 1차 캐시 덕분에 변경 감지 기능 동작, 데이터베이스를 통하지 않고 데이터를 바로 조회할 수 있다

동등성 비교 수준이 아니라 주소값이 같은 인스턴스를 반환한다

- 영속성 컨텍스트가 같으면 엔티티를 비교할 때 다음 조건을 만족한다
  - 동일성 : ==
  - 동등성 : equals
  - 데이터베이스 동등성 : 식별자가 같다

## 프록시 심화 주제

### 영속성 컨텍스트와 프록시

영속성 컨텍스트는 프록시로 조회된 엔티티에 대해서 같은 엔티티를 찾는 요청이 오면

원본 엔티티가 아닌 처음 조회된 프록시를 반환한다

원본 엔티티를 먼저 조회하면 이미 데이터베이스에서 조회했으므로 프록시를 반환하지 않고 원본을 반환한다

### 프록시 타입 비교
프록시는 원본 엔티티를 상속 받아서 만들어지므로 프록시로 조회한 엔티티의 타입을 비교할 때는

== 비교 X -> instanceof 를 사용해야함

## 성능 최적화

### N + 1 문제
> 회원과 주문정보가 1:N, N:1 양방향 연관관계, Member.orders 를 즉시로딩으로 설정

```java
// JPQL
select m from Member m
```
위 JPQL 실행 시 Member 의 orders 를 즉시로딩하게 된다

```java
SELECT * FROM MEMBER // 1번 실행으로 회원 5명 조회
SELECT * FROM ORDERS WHERE MEMBER_ID=1 // 회원과 연관된 주문
SELECT * FROM ORDERS WHERE MEMBER_ID=2 // 회원과 연관된 주문
SELECT * FROM ORDERS WHERE MEMBER_ID=3 // 회원과 연관된 주문
SELECT * FROM ORDERS WHERE MEMBER_ID=4 // 회원과 연관된 주문
SELECT * FROM ORDERS WHERE MEMBER_ID=5 // 회원과 연관된 주문
```

회원 조회 SQL 로 5명의 회원 엔티티를 조회, 그리고 각 회원 엔티티와 연관된 주문 컬렉션을 즉시 로딩하므로

총 5번의 SQL 추가 실행 -> N + 1 문제

즉시 로딩은 JPQL 을 실행할 때 N + 1 문제가 발생할 수 있다

### 지연 로딩과 N + 1 
회원과 주문을 지연 로딩으로 설정해도 N + 1 문제에서 자유로울 수 없다

### 페치 조인 사용
N + 1 문제를 해결하는 가장 일반적인 방법이다

### N + 1 정리
즉시 로딩은 사용하지 않고 지연 로딩만 사용하는 것 권장
- @OneToOne, @ManyToOne : 기본 페치 전략 -> 즉시 로딩
- @OneToMany, @ManyToMany : 기본 페치 전략 -> 지연 로딩

  @OneToOne, @ManyToOne 은 fetch = FetchType.LAZY 로 설정해서 지연 로딩으로 사용하자

## 읽기 전용 쿼리의 성능 최적화
엔티티가 영속성 컨텍스트에 관리되면 1차 캐시부터 변경감지까지 얻을 수 있는 혜택 많다

하지만 영속성 컨텍스트는 변경 감지를 위해 스냅샷 인스턴스를 보관하여 메모리를 사용하는 단점있다

100건의 구매 내용을 출력하는 단순한 로직이 있다. 조회나 수정할 일 없이 딱 한 번만 읽어서 출력하면 될 때는
<br> 읽기 전용으로 엔티티를 조회하면 메모리 사용량을 최적화할 수 있다

### 스칼라 타입으로 조회 
엔티티가 아닌 스칼라 타입으로 모든 필드를 조회하는 것

예) select o.id, o.name, o.price from Order o

### 읽기 전용 트랜잭션 사용
@Transactional(readOnly = true)

스프링에서 하이버네이트 세션의 플러시 모드를 MANUAL 로 설정.

강제로 플러시하지 않는 한 플러시가 일어나지 않는다, 엔티티의 등록, 수정, 삭제 동작 X

### 트랜잭션 밖에서 읽기
트랜잭션 없이 엔티티를 조회한다는 뜻

@Transactional(propagation = Propagation.NOT_SUPPORTED)

## 배치 처리 
수천에서 수만 건 이상의 엔티티를 한 번에 등록할 때 주의점

영속성 컨텍스트에 엔티티가 계속 쌓여 메모리 부족 오류 발생
### JPA 등록 배치
영속성 컨텍스트에 엔티티가 쌓이는 것을 방지하기 위해 플러시하고 영속성 컨텍스트를 초기화해야 한다

-> for 문에서 100의 배수 인덱스에서 플러시, 초기화하는 로직 추가

### 트랜잭션을 지원하는 쓰기 지연과 애플리케이션 확장성

트랜잭션을 지원하는 쓰기 지연과 변경감지 기능의 진짜 장점은
<br>데이터베이스 테이블 로우에 락이 걸리는 시간을 최소화한다는 점
- 트랜잭션을 커밋해서 영속성 컨텍스트를 플러시하기 전까지는 데이터베이스에 데이터를 등록,수정,삭제하지 않는다
따라서 커밋 직전까지 데이터베이스 로우에 락을 걸지 않는다

```java
update(memberA) // UPDATE SQL A
비즈니스로직A(); // UPDATE SQL
비즈니스로직B(); // UPDATE SQL
commit();
```
SQL 을 직접 다루면 update(memberA) 를 호출할 때 데이터베이스 테이블로우에 락을 건다
<br>이 락은 비즈니스로직 A, 비즈니스로직 B 를 모두 수행하고 커밋될 때까지 유지한다

JPA 는 커밋을 해야 플러시를 호출하고 데이터베이스에 수정 쿼리를 보낸다
쿼리를 보내고 바로 트랜잭션을 커밋하므로 데이터베이스에 락이 걸리는 시간을 최소화한다

- 사용자가 증가하면 서버를 증설하면 되지만 데이터베이스 락은 서버 증설만으로는 해결할 수 없다
- 오히려 서버를 증설할 수록 더 많은 데이터베이스 락이 걸린다

JPA 의 쓰기 지연 기능은 데이터베이스에 락이 걸리는 시간을 최소화해서 동시에 더 많은 트랜잭션을 처리할 수 있다

## 정리
- JPA 의 예외는 트랜잭션 롤백을 표시하는 예외와 표시하지 않는 예외로 나눈다.
트랜잭션을 롤백하는 예외는 심각한 예외이므로 트랜잭션을 강제로 커밋해도 커밋되지 않고 롤백된다
- 같은 영속성 컨텍스트의 엔티티를 비교할 때는 동일성 비교를 할 수 있지만 영속성 컨텍스트가 다르면 동일성 비교에 실패한다
따라서 잘 변하지 않는 비즈니스 키를 사용한 동등성 비교를 해야한다
- JPA 를 사용할 때는 N+1 문제를 가장 조심해야한다. 주로 페치조인을 사용해서 해결
- 대량의 엔티티를 배치 처리하려면 적절한 시점에 플러시를 호출하고 영속성 컨텍스트를 초기화해야함


# 16강 트랜잭션과 락, 2차 캐시 

트랜잭션 기초와 JPA 가 제공하는 낙관적 락과 비관적 락에 대해 알아보자
## 트랜잭션과 락

### 트랜잭션과 격리 수준
트랜잭션은 ACID
- 원자성(Atomicity) : 트랜잭션 내에서 실행한 작업들은 하나의 작업인 것처럼 , All or Nothing 
- 일관성(Consistency) : 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야한다. 예를 들어 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야한다
- 격리성(Isolation) : 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다. 동시에 같은 데이터를 수정하지 못하도록 하는 것
- 지속성(Durability) : 트랜잭션을 성공적으로 끝내면 결과가 항상 기록되어야한다. 시스템에 문제가 생겨도 데이터베이스 로그등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다

**트랜잭션 격리 수준**

- READ UNCOMMITED(커밋되지 않은 읽기)
- READ COMMITED(커밋된 읽기)
- REPEATABLE READ(반복 가능한 읽기)
- SERIALIZABLE(직렬화 가능)

순서대로 READ UNCOMMITED 의 격리 수준이 가장 낮고 SERIALIZABLE 의 격리 수준이 가장 높다

격리 수준이 낮을 수록 동시성은 증가하지만 격리 수준에 따른 문제가 발생한다

- DIRTY READ
- NON-REPEATABLE READ(반복 불가능한 읽기)
- PHANTOM READ

애플리케이션 대부분 동시성 처리가 중요하므로 READ COMMITED 격리 수준을 기본으로 사용한다

일부 중요한 비즈니스 로직에 더 높은 격리 수준이 필요하면 잠금 기능을 사용하면 된다

### 낙관적 락과 비관적 락 기초

- 낙관적 락 : 충돌이 발생하지 않는다고 낙관적으로 가정. 데이터베이스가 제공하는 락 기능을 사용하지 않고 JPA 가 제공하는 버전 관리 기능을 사용한다
<br> 애플리케이션이 제공하는 락. 트랜잭션을 커밋하기 전까지는 트랜잭션의 충돌을 알 수 없다
- 비관적 락 : 충돌이 발생한다고 가정하고 우선 락을 걸고 보는 방법. 데이터베이스가 제공하는 락 기능을 사용<br> 대포적으로 select for update 구문이 있다

### @Version
JPA 가 제공하는 낙관적 락을 사용하려면 @Version 을 사용해서 버전 관리 기능을 추가해야한다

<br> 적용 가능 타입

- Long
- Integer
- Short
- Timestamp

엔티티에 버전 관리용 필드를 하나 추가하고 @Version 을 붙이면 된다

이제부터 엔티티를 수정할 때 마다 버전이 하나씩 증가한다

그리고 엔티티를 수정할 때 조회 시점의 버전과 수정 시점의 버전이 다르면 예외가 발생한다

예를 들어 트랜잭션 1이 조회한 엔티티를 수정하고 있는데 트랜잭션 2에서 같은 엔티티를 수정하고 커밋해서 버전이 증가해버리면

트랜잭션 1이 커밋할 때 버전 정보가 다르므로 예외가 발생한다

**최초 커밋만 인정하기 적용**

### JPA 낙관적 락

- NONE
  - 락 옵션을 적용하지 않아도 엔티티에 @Version 이 적용된 필드가 있으면 낙관적 락 적용
  - 조회한 엔티티를 수정할 때 다른 트랜잭션에 의해 변경되지 않아야 한다. 조회 시점부터 수정 시점까지 보장
  - 두 번의 갱실 분실 문제를 예방
- OPTIMISTIC
  - @Version 만 적용했을 때는 엔티티를 수정해야 버전을 체크하지만 이 옵션을 추가하면 엔티티를 조회만 해도 버전을 체크한
  - 조회 시점부터 트랜잭션 끝날 때까지 조회한 엔티티가 변경되지 않음을 보장한다
  - DIRTY READ 와 NON-REPEATABLE READ 방지
- OPTIMISTIC_FORCE_INCREMENT
  - 게시물과 첨부파일이 일대다, 다대일의 양방향 관계에서 단순히 첨부파일만 추가하면 게시물의 버전은 증가하지 않는다
  - 해당 게시물은 물리적으로는 변경되지 않았지만 논리적으로는 변경되었다
  - 이때 게시물의 버전도 강제로 증가하려면 이 옵션을 사용하면 된다

### JPA 비관적 락
- 엔티티가 아닌 스칼라 타입을 조회할 때도 사용할 수 있다
- 데이터를 수정하는 즉시 트랜잭션 충돌 감지

#### PESSIMISTIC_WRITE
비관적 락이라 하면 일반적으로 이 옵션을 뜻함. 데이터베이스에 쓰기 락을 걸 때 사용한다
- 데이터베이스에 쓰기 락을 건다
- select for update 를 사용해서 락을 건다 
- NON-REPEATABLE READ 를 방지한다. 락이 걸린 로우는 다른 트랜잭션이 수정할 수 없다

#### PESSIMISTIC_READ 
데이터를 읽기만 하고 수정하지 않는 용도로 락을 걸 때 사용. 일반적으로 잘 사용하지 않음

#### PESSIMISTIC_FORCE_INCREMENT
비관적 락중 유일하게 버전 정보 사용

버전 정보를 강제로 증가 시킨다

### 비관적 락과 타임아웃
비관적 락을 사용하면 락을 획득할 때까지 트랜잭션이 대기한다

무한정 대기할 수 없으므로 타임아웃 시간을 줌

대기해서 응답이 없으면 LockTimeoutException 예외 발생

## 2차 캐시

### 1차 캐시와 2차 캐시
네트워크를 통해 데이터베이스에 접근하는 시간 비용은 애플리케이션 서버에서 내부 메모리에 접근하는 시간 비용보다 수만에서 수십만 배 이상 비싸다

따라서 조회한 데이터를 메모리에 캐시해서 데이터베이스 접근 횟수를 줄이면 애플리케이션 성능을 획기적으로 개선할 수 있다

일반적인 웹 애플리케이션 환경은 트랜잭션을 시작하고 종료할 때까지만 1차 캐시가 유효하다. OSIV 를 사용해도 클라이언트의 요청이 들어올 때부터 끝날 때까지만 1차 캐시가 유효하다

따라서 애플리케이션 전체로 보면 데이터베이스 접근 횟수를 획기적으로 줄이지는 못한다

하이버네이트를 포함한 대부분의 JPA 구현체들은 애플리케이션 범위의 캐시를 지원한다 이것을 **공유 캐시 또는 2차 캐시**라 한다

### 1차 캐시
1차 캐시는 영속성 컨텍스트 내부에 있다

엔티티 매니저로 조회하거나 변경하는 모든 엔티티는 1차 캐시에 저장된다

트랜잭션을 커밋하거나 플러시를 호출하면 1차 캐시에 있는 엔티티의 변경 내역을 데이터베이스에 동기화 한다

1차 캐시의 동작 방식
1. 최초 조회 시 1차 캐시에 엔티티 없으므로
2. 데이터베이스에서 엔티티 조회
3. 1차 캐시에 보관하고
4. 1차 캐시에 보관한 결과를 반환
5. 이후 같은 엔티티를 조회하면 1차 캐시에 같은 엔티티가 있으므로 DB 를 조회하지 않고 1차 캐시의 엔티티를 반환

1차 캐시는 기본적으로 영속성 컨텍스트 범위의 캐시다

### 2차 캐시
애플리케이션에서 공유하는 캐시를 JPA 는 공유 캐시라 하는데 일반적으로 2차 캐시라 부른다

2차 캐시의 동작 방식
1. 영속성 컨텍스트는 엔티티가 필요하면 2차 캐시를 조회한다
2. 2차 캐시에 엔티티가 없으면 데이터베이스를 조회해서
3. 결과를 2차 캐시에 보관한다
4. 2차 캐시는 자신이 보관하고 있는 엔티티를 복사해서 반환한다
5. 2차 캐시에 저장되어 있는 엔티티를 조회하면 복사본을 만들어 반환한다

2차 캐시는 동시성을 극대화하려고 캐시한 객체를 직접 반환하지 않고 복사본을 만들어서 반환한다

캐시를 객체 그대로 반환하면 여러 곳에서 같은 객체를 동시에 수정하는 문제가 발생할 수 있다

이 문제를 해결하려면 객체에 락을 걸어야하는데 이는 동시성이 떨어질 수 있음

락에 비하면 객체를 복사하는 비용은 저렴. 따라서 2차 캐시는 복사본을 반환한다

- 2차 캐시는 영속성 유닛 범위의 캐시
- 2차 캐시는 복사본을 만들어서 반환
- 2차 캐시는 데이터베이스 기본 키를 기준으로 캐시하지만 영속성 컨텍스트가 다르면 객체 동일성 보장 X

### JPA 2차 캐시 기능

2차 캐시를 사용하려면 엔티티에 @Cacheable 을 사용하면 된다

```java
import javax.annotation.processing.Generated;

@Cacheable // 이 부분 추가
@Entity
public class Member {
  @Id @GeneratedValue
  private Long id;
  // ...
}
```

### 정리
- 트랜잭션의 격리 수준은 4단계가 있다. 격리 수준이 낮을수록 동시성은 증가하지만 격리 수준에 따른 문제가 발생한다
- 영속성 컨텍스트는 데이터베이스 트랜잭션이 READ COMMITTED 격리 수준이어도 애플리케이션 레벨에서 반복 가능한 읽기(REPEATABLE READ) 를 제공한다
- JPA 는 낙관적 락과 비관적 락을 지원한다.
- 2차 캐시를 사용하면 애플리케이션의 조회 성능을 극적으로 끌어올릴 수 있다