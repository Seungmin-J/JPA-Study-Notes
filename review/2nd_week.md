# 4장 엔티티 매핑

## 어노테이션
엔티티와 테이블을 매핑하기 위한 어노테이션들

- 객체와 테이블 매핑 : `@Entity`, `@Table`
- 기본 키 매핑 : `@Id`
- 필드와 컬럼 매핑 : `@Column`
- 연관관계 매핑 : `@ManyToOne`, `@JoinColumn`

### 기본 키 매핑
`@GeneratedValue` 를 사용해서 기본 키 매핑 전략을 선택

1. IDENTITY
2. SEQUENCE
3. TABLE
4. AUTO

#### 권장 식별자 선택 전략
기본 키는 다음과 같은 조건 만족해야함
1. null 값 허용x
2. 유일한 값
3. 변하지 않아야함

기본키를 선택하는 전략은 2가지
- 자연키
    - 비즈니스에 의미가 있는 키
    - 예 : 주민번호, 이메일, 전화번호
- 대리키
    - 비즈니스에 의미 없는 키, 임의로 만들어진 키
    - 예 : auto_increment, 시퀀스
#### 추천 전략은 대리키
자연키는 바뀌지 않는다고 확신할 수 없음<br>
비즈니스 환경은 언젠가 변한다

# 5장 연관관계 매핑 기초
객체와 테이블은 연관관계를 맺는 방법이 다르다

- 객체는 참조(주소)로 관계를 맺는다 : 예) member.team
    - 항상 단방향이다
    - 객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야한다 : <br>
member.team / team.member 각 엔티티에 필드로 가지고 있어야함


- 테이블은 외래 키로 관계를 맺는다 : JOIN 사용
    - member join team / team join member 양방향이다

### 양방향 연관관계의 주인
테이블은 외래키로 연관관계를 가지기에 **양방향**
엔티티를 양방향으로 연관관계를 가지려면 서로 참조해야하기에 참조가 둘인데 외래키는 하나다<br>
둘 사이에 차이가 발생하기때문에 주인을 정해야한다 주인은 외래키를 가지고 있는 곳이 주인이다<br>
연관관계의 주인을 정한다는 것은 외래키 관리자를 선택하는 것

```java
Member member1 = new Member("member1");
em.persist(member1);
Member member2 = new Member("member2");
em.persist(member2);

Team team1 = new Team("team1");
// 주인이 아닌 곳에만 연관관계 설정
team1.getMembers.add(member1);
team1.getMembers.add(member2);

em.persist(team1);
```
그리고 다음과 같이 조회하면 
```sql
SELECT * FROM member;
```
| member_id | username | team_id |
|-----------|----------|---------|
| member1   | 회원1      | null    |
| member2   | 회원2      | null    |

이유는 연관관계의 주인이 아닌 Team.members 에만 값을 저장했기 때문이다<br>

**연관관계의 주인만이 외래키의 값을 변경할 수 있다**

### 순수한 객체까지 고려한 양방향 연관관계
그렇다면 외래키를 가진 주인에만 값을 저장하고 주인이 아닌 곳에는 저장하지 않아도 되는가? 그렇지 않다
```java
Team team1 = new Team("team1");
Member member1 = new Member("member1");
Member member2 = new Member("member2");
member1.setTeam(team1);
member2.setTeam(team1);

List<Member> members = team1.getMembers();

System.out.println(members.size());

// 결과 - members.size(): 0
```

```java
Team team1 = new Team("team1");
Member member1 = new Member("member1");
Member member2 = new Member("member2");

member1.setTeam(team1);
team1.getMembers.add(member1);

member2.setTeam(team1);
team1.getMembers.add(member2);

List<Member> members = team1.getMembers();

System.out.println(members.size());

// 결과 - members.size(): 2
```
아래의 코드처럼 객체도 고려하여 작성하여야한다

> 정리
> - 단방향 매핑만으로 테이블과 객체의 연관관계 매핑은 완료되었다
> - 단방향을 양방향으로 만들면 반대방향으로 객체 그래프 탐색 기능이 추가된다
> - 양방향 연관관계를 매핑하려면 객체에서 양쪽 방향 모두 관리해야한다

# 6장 다양한 연관관계 매핑

엔티티를 매핑할 때는 3가지를 고려해야한다
- 다중성(다대일, 일대다, 일대일, 다대다)
- 단방향, 양방향
- 연관관계의 주인

### 다중성
**1. 다대일**

다대일 관계에서 주인은 항상 다 쪽이다

예) 멤버와 팀 -> 멤버가 주인

**2. 일대다**

2-1. 일대다 단방향

하나의 팀은 여러 멤버를 참조하지만 멤버는 팀을 참조하지 못하는 관계

팀의 List<Member> members 필드는 멤버를 참조하지만 Member 는 참조 못함

단점으로 객체와 매핑된 데이터베이스에 FK가 없다

예) Team 엔티티에서 List 타입의 members 를 가지지만 team 테이블에는 FK가 없다

**일대다 단방향 보다는 다대일 양방향 매핑을 사용하기**

2-2. 일대다 양방향

존재하지 않는다

**3. 일대일**

3-1. 단방향

주 엔티티에 객체 참조, 주 테이블에 외래키

예) 멤버와 락커 - 멤버가 주 엔티티, 주 테이블이면 멤버가 락커 참조 외래키는 멤버 엔티티에 존재, 주인은 멤버

다대일 단방향과 비슷

3-2. 양방향

예) 멤버 테이블이 FK를 가짐

각 엔티티에서 서로 참조, 외래키를 가지고 있는 테이블의 엔티티가 연관관계의 주인(멤버)

따라서 주인이 아닌 락커의 엔티티에서 mappedBy 선언

**4. 다대다**

관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없다
그래서 보통 연결 테이블을 사용한다
>다음은 그 이유에 대해 설명

관계형 데이터베이스(RDBMS)가 다대다(Many-to-Many, M:N) 관계를 직접적으로 표현하지 못하는 이유는 그 설계 원칙과 데이터 무결성 보장을 위한 제약 때문입니다. 이를 자세히 설명드릴게요.

1. 관계형 데이터베이스의 기본 원칙
   테이블 구조: RDBMS는 데이터를 행(row)과 열(column)로 구성된 테이블로 저장합니다. <br>
   각 테이블은 고유한 기본 키(Primary Key, PK)를 가져 행을 식별합니다.<br>
   정규화: 데이터 중복을 줄이고 무결성을 유지하기 위해 정규화(Normalization)를 따릅니다. <br>
   다대다 관계를 직접 표현하면 정규화 원칙(특히 제1정규형, 1NF)을 위반하게 됩니다.<br><br>

   제1정규형(1NF) 요구사항
   모든 열 값은 **단일 값(Atomic Value)** 이어야 함.
   즉, **한 셀에 여러 값을 리스트 형태로 저장할 수 없음.**


2. 다대다 관계의 문제<br>
   다대다 관계란, 한 엔터티의 여러 인스턴스가 다른 엔터티의 여러 인스턴스와 연결되는 경우입니다. 예를 들어:

**학생(Student)** 과 강의(Course):
한 학생이 여러 강의를 수강 가능.
한 강의에 여러 학생이 참여 가능.
직접 표현 시도 시 문제
만약 Student 테이블에 Course를 직접 넣으려 하면:

Student_ID | Name  | Courses
-----------|-------|-----------------
1          | Alice | Math, Physics
2          | Bob   | Physics, Chem
문제 1: 비원자성(Non-Atomicity):<br>
Courses 열에 여러 값(Math, Physics)이 들어가 1NF 위반.
RDBMS는 리스트나 배열을 기본적으로 지원하지 않음.

문제 2: 데이터 무결성:<br>
Courses 값이 문자열로 저장되면, 검색/조인/업데이트가 비효율적이고 오류 발생 가능성 높음(예: "Physics" 오타).
문제 3: 역방향 관계 표현 불가:
Course 테이블에서 학생 목록을 표현하려면 또 다른 중복 열이 필요 → 중복과 복잡성 증가.

<br>
3. 해결책: 조인 테이블(Join Table)
   RDBMS는 다대다 관계를 직접 표현하지 못하므로, 중간 테이블(또는 조인 테이블, Junction Table)을 사용해 이를 해결합니다.

조인 테이블 예시

Student 테이블:

| Student_ID | Name|
| -----------|------|
| 1          | Alice |
| 2          | Bob |

Course 테이블:

Course_ID | Title
----------|---------
1         | Math
2         | Physics
Student_Course (조인 테이블):

Student_ID | Course_ID
-----------|-----------
1          | 1
1          | 2
2          | 2
동작 방식
Student_Course는 Student와 Course의 외래 키(Foreign Key, FK)를 쌍으로 저장.<br>
각 행은 단일 관계를 나타내며, 1NF를 만족.<br>
다대다 관계를 두 개의 일대다(1:N) 관계로 분해:<br>
Student → Student_Course (1:N).<br>
Course → Student_Course (1:N).<br>
---

# 7장 고급 매핑

## 1. 상속 관계 매핑
- **조인 전략**
  - 부모와 자식 테이블을 모두 생성하고 자식은 부모의 기본 키를 받아서 기본키+외래키 사용
  - 객체는 타입이 있지만 테이블은 타입이 없기 때문에 타입을 구분하는 컬럼을 추가해야함(DTYPE)
  - **장점** : 테이블 정규화, 외래키 참조 무결성 제약조건, 저장공간 효율성
  - **단점** : 조인이 많이 사용되어 성능 저하, 조회 쿼리가 복잡하다, INSERT 문을 2번 실행한다


- **단일 테이블 전략**
    - 테이블 하나만 사용한다
    - 예) ITEM 테이블 안에 ALBUM, AUTHOR, ACTOR 등 모든 컬럼이 다 들어간다 
    - 그렇기 때문에 해당되는 컬럼을 제외하면 모두 null 이 들어간다
    - 장점 : 조인이 필요없어서 성능이 좋다, 조회 쿼리가 단순
    - 단점 : 자식 엔티티가 매핑한 모든 컬럼은 null 을 허용해야한다, 단일 테이블에 모두 저장하기때문에 상황에 따라 성능이 오히려 안좋아질 수 있다
    - 구분컬럼을 꼭 사용해야한다 `@DiscriminatorColumn` 을 꼭 설정해야함


- **구현 클래스마다 테이블 전략**
    - 각 엔티티마다 테이블을 만든다, 필요한 모든 컬럼을 갖는다
    - 비추

- **@MappedSuperclass**
    - `@Entity` 는 실제 테이블과 매핑되지만 `@MappedSuperclass` 는 테이블과 매핑X
    - 단순히 매핑정보를 상속할 경우에 사용

## 2. 식별, 비식별 관계

### 식별
- 부모 테이블의 기본 키를 내려받아서 자식 테이블의 기본키+외래키로 사용하는 관계
### 비식별
- 부모 테이블의 기본 키를 내려받아서 자식 테이블의 외래키로만 사용한다

**필수적 비식별** : 외래키에 NULL 을 허용하지 않음 연관관계 필수로 맺어야함 <br>

**선택적 비식별** : 외래키에 NULL 을 허용

### 식별, 비식별 관계 정리

- 식별 관계는 부모테이블의 기본 키를 자식 테이블로 전파하면서 자식 테이블의 기본 키 컬럼이 계속 늘어남
- 식별 관계를 사용할 때 기본 키로 비즈니스 의미가 있는 자연 키를 조합하는 경우가 많음, 비즈니스 요구사항은 시간이 지남에 따라 변하게 되어있다 자연 키 컬럼들이 자식에 손자까지 전파되면 변경하기 힘들다
- 식별 관계는 대부분 복합 기본 키를 사용한다 따라서 복합 키 클래스를 만들어서 매핑해야함 -> 많은 노력이 필요
- 식별 관계의 장점은 부모 키 컬럼을 자식이 가지고 있기 때문에 특정 상황에 하위 테이블만으로 조인없이 조회가능

> 결론 : 필수적 비식별 관계를 쓰는게 좋다

### 연관관계 설계 방법 (조인 컬럼, 조인 테이블)
굳이 조인 테이블 써야함?

## 7장의 실전예제에서 상속 관계 매핑과 MappedSuperclass 만 다룬다
-> 이 말은 즉 저 두 가지만 알고 있으면 된다 